This one looks like it is called by "spurious" check calls because of
lookahead.

test_clingcon: ../../libclingcon/src/solver.cc:691: bool Clingcon::Solver::check(Clingcon::AbstractClauseCreator&, bool): Assertion `ass.decision_level() == 0' failed.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
test_clingcon is a Catch v1.5.6 host application.
Run with -? for options                                                                                                                                                                                                                                                        

-------------------------------------------------------------------------------
fs
  fsd
-------------------------------------------------------------------------------
../../libclingcon/tests/fs.cc:104
...............................................................................

./../libclingcon/tests/fs.cc:[0;37m110../../libclingcon/tests/fs.cc:: 110 [0mAILED[1;31mFAILED:
  {Unknown expression after the reported line}
due to a fatal error condition:
:
  {Unknown expression after the reported line}
due to a fatal error condition:
  configuration: 2
  program: 
  1 { cycle(T,U) : task(U), U != T } 1 :- task(T).
  1 { cycle(T,U) : task(T), U != T } 1 :- task(U).
  
  reach(M) :- M = #min { T : task(T) }.
  reach(U) :- reach(T), cycle(T,U).
  :- task(T), not reach(T).
  
  1 { start(T) : task(T) } 1.
  
  permutation(T,U) :- cycle(T,U), not start(U).
  
  seq((T,M),(T,M+1),D) :- task(T), duration(T,M,D), machine(M+1).
  seq((T1,M),(T2,M),D) :- permutation(T1,T2), duration(T1,M,D).
  
  &diff { T1-T2 } <= -D :- seq(T1,T2,D).
  &diff { 0-(T,M) } <= 0 :- duration(T,M,D).
  &sum { (T,M)-0 } <= B :- duration(T,M,D), B=bound-D.
  
  #show permutation/2.
  
              machine(1).      machine(2).
  task(a). duration(a,1,3). duration(a,2,4).
  task(b). duration(b,1,1). duration(b,2,6).
  task(c). duration(c,1,5). duration(c,2,5).
  
  #const bound=16.
  
  configuration: 2
  program: 
  1 { cycle(T,U) : task(U), U != T } 1 :- task(T).
  1 { cycle(T,U) : task(T), U != T } 1 :- task(U).
  
  reach(M) :- M = #min { T : task(T) }.
  reach(U) :- reach(T), cycle(T,U).
  :- task(T), not reach(T).
  
  1 { start(T) : task(T) } 1.
  
  permutation(T,U) :- cycle(T,U), not start(U).
  
  seq((T,M),(T,M+1),D) :- task(T), duration(T,M,D), machine(M+1).
  seq((T1,M),(T2,M),D) :- permutation(T1,T2), duration(T1,M,D).
  
  &diff { T1-T2 } <= -D :- seq(T1,T2,D).
  &diff { 0-(T,M) } <= 0 :- duration(T,M,D).
  &sum { (T,M)-0 } <= B :- duration(T,M,D), B=bound-D.
  
  #show permutation/2.
  
              machine(1).      machine(2).
  task(a). duration(a,1,3). duration(a,2,4).
  task(b). duration(b,1,1). duration(b,2,6).
  task(c). duration(c,1,5). duration(c,2,5).
  
  #const bound=16.
  
  SIGABRT - Abort (abnormal termination) signal
  SIGABRT - Abort (abnormal termination) signal


===============================================================================
===============================================================================
test cases:   3 |   2 passed | 1 failed
assertions: 625 | 623 passed | 2 failed

pure virtual method called
terminate called without an active exception
test cases:   4
